# memblock分配器

内核初期对物理内存的管理是粗粒度的，启动初期内核通过中断向BIOS发出请求获取物理内存信息，BIOS会向内核返回检测到的物理内存结果，内核将管理这些跨度较大的物理内存用于初期内存分配，这就是memblock分配器。

> *dmesg | grep BIOS-e820查看物理内存信息*

![img](https://i-blog.csdnimg.cn/direct/254099c9cf254732b3189777d69a1e67.png)

memblock仅仅将物理内存划分为usable和reserved两类，其中usable是普通内存，reserved内存保留给内核使用或没有实际内存条

memblock分配器把每一段物理地址视作为一个region，通过数组保存所有的usable region和reserved region

![img](https://i-blog.csdnimg.cn/direct/55c4e21da2e94381bb15c0297bf165eb.png)

内核需要通过memblock分配器申请一段空间以建立4KB大小的页帧为主内存分配器伙伴系统启动作准备。一旦伙伴系统启动后memblock分配器就需要停用，此后物理内存的分配统一交给更细粒度的伙伴系统所管理。

# 内存域

**内核获取物理内存信息后需要建立建立node信息，每一个node又被细分为多个zone。**

![img](https://i-blog.csdnimg.cn/direct/6f0f60c8f71349d49f06fecdcf01ae36.png)

node在内核中用**pglist_data**表示

```c
typedef struct pglist_data {
	struct zone node_zones[MAX_NR_ZONES]; /* node对应的内存域zone数组 */
	struct zonelist node_zonelists[MAX_ZONELISTS]; /* 备用zone数组 */
	//...	
	unsigned long node_start_pfn;	/* node中首个页帧编号 */
	//...
	int node_id;
	struct pglist_data *pgdat_next;
	//...
} pg_data_t;
```

内核把一个节点划分为DMA内存域*(ZONE_DMA\ZONE_DMA32)*、普通内存域*(ZONE_NORMAL)*

*DMA内存域用于外设和系统数据传输*

*普通内存域用户可用，也保存了大量内核数据结构*

内存域在内核中用**zone**表示

```c
struct zone {
    //...
	long lowmem_reserve[MAX_NR_ZONES];	/* 保留的页帧 */
	//...
    struct pglist_data	*zone_pgdat;
	//...
    struct free_area	free_area[NR_PAGE_ORDERS]; /* 管理的页帧 */
};
```

## 备用域

NUMA机器支持CPU访问其他CPU的内存，这种情况发生在直接node内存不足的情况，内核为每一个node维护了一个备用域数组，备用域保存在**node_zonelists**中，每一个数组项对应一个node，node_zonelists是根据节点距离升序的*(内核尽可能保证跨node访存的距离短以降低延迟)*

struct zonelist保存了备用node的zone信息，这些zone按照一种等级次序保存于数组中

> 在需要申请其他node内存域中的内存时，内核总是试图分配廉价的内存，如果失败则分配较昂贵的内存
>
> **内存域越廉价意味着该内存域和内核数据的联系越小**
>
> ZONE_NORAML要比ZONE_DMA\ZONE_DMA32廉价

```c
struct zonelist {
	struct zoneref _zonerefs[MAX_ZONES_PER_ZONELIST + 1];
};
struct zoneref {
	struct zone *zone;	/* Pointer to actual zone */
	//...
};
```

![img](https://i-blog.csdnimg.cn/direct/aac053278d90470db7ba6daf1e09db0a.png)

# 内存布局

64位环境地址空间被划分为3部分，用户空间位于低地址范围，内核空间位于高地址范围，中间有一大片非规范区域被保留不使用。内核空间

![img](https://i-blog.csdnimg.cn/direct/c7480592dcc04b6a8a3a7259a77341cc.png)

事实上物理内存的低端和高端往往保留给内核所使用，Linux将物理内存的划分导入到了文件中可以让用户查看。

> *cat /proc/iomem*

![img](https://i-blog.csdnimg.cn/direct/4038094925e5488ab5f2fca3e308ecd7.png)

**内核会将数据内核部分的物理地址简单映射到高端虚拟地址，虚拟地址和物理地址只是相差一个整数。因此大部分情况下内核空间的虚拟地址翻译是不需要查询页表的。***(内核空间中有一个特殊的vmalloc区，其虚拟地址与物理地址不是直接映射)*

![img](https://i-blog.csdnimg.cn/direct/4a1376e4a9564d82a04f9339794342f6.png)

> *cat /boot/System.map可以查看虚拟地址空间的布局*

```txt
root@Ubuntu:/# cat /boot/System.map-5.4.0-192-generic | grep -w "_text"

ffffffff81000000 T _text       /* 内核代码段起始位置 */ 

root@Ubuntu:/# cat /boot/System.map-5.4.0-192-generic | grep -w "_etext"

ffffffff81e00df1 T _etext		

root@Ubuntu:/# cat /boot/System.map-5.4.0-192-generic | grep -w "_edata"

ffffffff82c57180 D _edata		/* 内核数据段结束位置 */

root@Ubuntu:/# cat /boot/System.map-5.4.0-192-generic | grep -w "_end"

ffffffff8402c000 B _end			/* BSS段结束位置 */
```

*内核代码段被映射到了地址空间的[0xffffffff81000000,0xffffffff81e00df1)，内核数据、bss段被映射到了地址空间[ffffffff81e00df1,0xffffffff8402c000)*

# 
