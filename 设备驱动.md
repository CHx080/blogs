

# 设备驱动模型

设备管理是操作系统的任务之一，在Linux内核中设备管理是最为庞大复杂的。设备驱动方面的代码实现很多都与体系结构紧耦合。设备驱动层是内核与硬件交互的关键。**设备驱动层涉及到设备、总线、设备驱动程序**，关系及其复杂，内核基于面向对象的思想组织这些组件，从而对用户提供一个统一的视图(**/sys**)。

![image-20250111135115554](C:/Users/chx11/AppData/Roaming/Typora/typora-user-images/image-20250111135115554.png)

- *block: 块设备*
- *bus: 总线*
- *devices: 硬件设备*

......

## kobject

设备驱动模型的核心对象是kobject，可以把它理解为一个**抽象基类**(*下文许多结构都有内嵌kobject*)，用户通过sys目录所看到的所有**目录文件**都对应一个kobject的派生类。kobject之间具有层级关系。

```c
struct kobject{
	const char *k_name;			
    struct kref kref;			//引用计数
    struct list_head entry;		//kobject链表
    struct kobject *parent;		//父对象
    struct kset *kset;			//指向包含的kset
    struct kobj_type *ktype;
    struct dentry *dentry;		
};
```

**kset可以管理多个kobject**

```c
struct kset{
    struct subsystem *subsys; /*struct subsystem也是kobject的派生类，它用于管理多个kset和subsystem*/
    struct kobject_type *ktype;
    struct list_head list;    //kset所管理的kobject链表
    struct kobject kobj;	  //内嵌的kobject
    struct kset_hotplug_ops *hotplug_ops;
};
```

**将kobject直接内嵌于kset是一个非常巧妙的设计,它实现了一个简单的继承，这使得kset具备了kobject的所有属性，逻辑上kset就是kobject的派生类。**

![image-20250111143456752](C:/Users/chx11/AppData/Roaming/Typora/typora-user-images/image-20250111143456752.png)

![image-20250111144305623](C:/Users/chx11/AppData/Roaming/Typora/typora-user-images/image-20250111144305623.png)

> bus子系统包括一个pci子系统，pci子系统又依次包含驱动程序的一个kset。驱动程序kset包含一个串口的kobject

# 设备文件

设备文件用于访问扩展设备。这些文件不关联到硬盘或其他存储介质上(*通过ls观察到设备文件的大小为0*),而是建立与某个设备驱动程序的连接，以支持与扩展设备的通信。

设备文件通过设备号标识，文件名仅方便用户阅读。

![image-20250111151752847](C:/Users/chx11/AppData/Roaming/Typora/typora-user-images/image-20250111151752847.png)

​									*b标识块设备，c标识字符设备*

**Linux中设备文件只有块设备文件和字符设备文件2种，对于网卡有专门的套接字文件。**

## 设备号

设备号可以拆分为主设备号和从设备号。**主设备号标识设备驱动程序，从设备号标识具体设备**，这里的设备是逻辑设备，与物理设备存在多对一的关系。

*/dev/vda1、/dev/vda2、/dev/vda3是磁盘上的三个分区，内核将它们视作三个设备，其实它们在一个物理磁盘上。它们的主设备号都为252，代表它们的设备驱动程序相同*

## 设备管理

内核需要将一致的字符设备和块设备分别管理。内核通过**kobj_map**散列表管理所有设备,**主设备号作为关键字**

```c
struct kobj_map {
	struct probe {
    	struct probe *next;	//单链表处理哈希冲突
        dev_t dev;			//设备号
        unsigned long range;//从设备号范围 [MINORS(dev),MINORS(dev)+range-1]
        //...
        void *data;
    } *probes[255];
	struct mutex *lock;
};
static struct kobj_map bdev_map;	//管理所有块设备
static struct kobj_map cdev_map;	//管理所有字符设备
```

**bdev_map和cdev_map最大的区别在于probe字段中data不同，对于字符设备data指向struct cdev;对于块设备data指向struct genhd**

![image-20250111154819776](C:/Users/chx11/AppData/Roaming/Typora/typora-user-images/image-20250111154819776.png)

### 字符设备

内核使用**struct cdev**描述一个**物理字符设备**

```c
struct cdev{
    struct kobject kobj;
    const struct file_operations *ops; //文件操作,与硬件通信
    struct list_head list;			   //所有关于该物理字符设备的设备文件链表
    dev_t dev;						   //设备号
    unsigned int count;				   //从设备号数目
};
```

### 文件操作化

Linux遵循了Unix一切皆文件的理念。它需要做到让用户像访问文件一样访问设备。关键在于对设备文件inode对象进行特殊化处理。

```c
struct inode {
//...
	dev_t i_rdev;	//设备号
//...
	umode_t i_mode;	//文件类型(普通、目录、管道、套接字、块、字符、符号)
//...
	struct file_operations *i_fop;
//...
    union {	//要么是块设备文件，要么是字符设备文件，要么都不是
        struct block_device *i_bdev;
        struct cdev *i_cdev;
    };
//...
};
```

打开一个设备文件时需要创建inode对象，内核调用**init_special_inode**方法来初始化设备文件inode对象

```c
void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)
{
    inode->i_mode = mode;
    if (S_ISCHR(mode)) { //如果是字符设备
        inode->i_fop = &def_chr_fops;
        inode->i_rdev = rdev;
    } else if (S_ISBLK(mode)) { //如果是块设备
        inode->i_fop = &def_blk_fops;
        inode->i_rdev = rdev;
    }
    else //错误处理
}
```

暂时只关注字符设备inode的设置，内核为字符设备inode的i_fop字段设置了def_chr_fops的地址，def_chr_fops是一个通用(抽象)字符设备操作方法，它与具体设备实现无关，def_chr_fops只有一个字段

```c
struct file_operations def_chr_fops={
    .open=chrdev_open
};
```

> 字符设备彼此非常不同。因而内核在开始不能提供多个操作，因为每个设备文件都需要一组独立、自定义的操作。因而chrdev_open函数的主要任务就是向该结构填入适用于已打开设备的函数指针，使得能够在设备文件上执行有意义的操作，并最终能够操作设备自身。
