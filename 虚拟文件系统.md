# 虚拟文件系统

Linux支持多种文件系统，不同的文件系统管理文件的方式并不一致，如果直接对用户暴露具体文件系统操作的方法集无疑是增加了用户编程难度。操作系统的目的之一就是向上提供便捷服务，因此接口抽象化的任务就交给了内核实现。Linux引入**==虚拟文件系统(VFS)==**层以实现方法抽象，用户只需要与VFS层进行交互，VFS将任务移交给具体的文件系统——**==用户发出的读写请求由具体文件系统实现，也可能采用VFS提供的默认方法实现==**

![](C:/Users/chx11/AppData/Roaming/Typora/typora-user-images/image-20250110215739761.png)

Linux内核采用**面向对象**的思想设计虚拟文件系统，整个**==虚拟文件系统由4大组件构成——超级块对象(super block)、索引对象(inode)、文件对象(file)、目录项对象(dentry)==**

## 超级块对象

**==超级块对象用于标识特定的文件系统==**

VFS欲实现派发，则需要获取当前已挂载的文件系统，即需要以合适的数据结构描述并组织文件系统。

内核通过struct super_block 超级块对象描述文件系统。**==超级块对象保存了文件系统的属性数据==*。

```c
struct super_block {
    struct list_head s_list; /* 将该成员置于起始处 */
    dev_t s_dev;
    unsigned long s_blocksize;
    unsigned char s_blocksize_bits;
    unsigned char s_dirt;
    unsigned long long s_maxbytes; /* 最大的文件长度 */
    struct file_system_type *s_type;
    struct super_operations *s_op;
    unsigned long s_flags;
    unsigned long s_magic;
    struct dentry *s_root;
    struct xattr_handler **s_xattr;
    struct list_head s_inodes; /* 所有inode的链表 */
    struct list_head s_dirty; /* 脏inode的链表 */
    struct list_head s_io; /* 等待回写 */
    struct list_head s_more_io; /* 等待回写，另一个链表 */
    struct list_head s_files;
    struct block_device *s_bdev;
    struct list_head s_instances;
    char s_id[32]; /* 有意义的名字 */
    void *s_fs_info; /* 文件系统私有信息 */
    u32 s_time_gran;
}
```



## 索引对象

## 文件对象

## 目录项对象

## VFS四大组件关系

